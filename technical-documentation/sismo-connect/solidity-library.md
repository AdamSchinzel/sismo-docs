---
description: Verify proofs from your users
---

# Sismo Connect Solidity Library: Verify On-chain

The [Sismo Connect](../../readme/sismo-connect.md) Solidity Library is built on top of the [Hydra-S2 Verifier](https://github.com/sismo-core/hydra-s2-zkps) and allows to easily verify proofs from your users **on-chain**. You can see a full guide on how to integrate Sismo Connect into your application [here](../../tutorials/sismo-connect/gate-your-contracts-with-sismo-connect-advanced.md).

<figure><img src="../../.gitbook/assets/onchain (3).png" alt=""><figcaption><p>Sismo Connect onchain full flow</p></figcaption></figure>

This page will detail all the specifications of the Sismo Connect Solidity Library.

You can find the Solidity Lib GitHub repository [here](https://github.com/sismo-core/zk-connect-packages/tree/main/packages/zk-connect-solidity).

{% hint style="info" %}
Learn more about Sismo zero-knowledge proofs and use cases [**here**](../../technical-concepts/vault-and-proof-identifiers.md).

Learn more about Sismo Connect [**here**](../../readme/sismo-connect.md).
{% endhint %}

## Usage

Import the SismoConnectLib to your contract:

```solidity
import "./libs/sismo-connect/SismoConnectLib.sol";
```

Then:

* **Inherit** your contract from the Sismo Connect Library
* **Call** the SismoConnect constructor in the constructor of your contract
* **Create** the request objects:
  * Create a [Claim](./#claim) OR an [Auth](./#auth) object in the constructor.
  *   Create a [signedMessage](./#signedmessage):

      * By hardcoding a signedMessage in your contract, you can ensure that the sismoConnectResponse have the same signed message that the one you hardcoded.

      > **Example 1**: Define a specific message (like the one used fo Sign-in with Ethereum), so the lib can verify the user use the same message to generate the proof.

      * You can also define it by passing it as argument of a function of your contract. And verify it regarding the sismoConnectResponse one.

      > **Example 2**: A user need to specify an address to receive an airdrop. He will send his address as parameter of the contract function, so the lib can verify that is the same address that the one used to generate the proof.

This will then allow you to check if the proof the user wants to check corresponds to the proof expected by the contract.

```solidity
import "sismo-connect-solidity/libs/sismo-connect/SismoConnectLib.sol";

contract MyContract is SismoConnect { // inherits from Sismo Connect library
 // the Claim object we want to verify the SismoConnectResponse with
 ClaimRequest claim;
 
 // you can also have an Auth
 // AuthRequest auth;
 
 // Or a signedMessage
 // SignatureRequest signedMessage;
 
 // call SismoConnect constructor with your appId
 constructor(bytes16 appId, bytes16 groupId) SismoConnect(appId) {
  // creation of the claim with a groupId
  claim = buildClaim({groupId: groupId});
  
  // you can also pass in arguments other objects in order to create
  // an Auth
  // auth = buildAuth({authType: AuthType.VAULT});

  // Or a signedMessage request
  // signedMessage = buildSignature({message: message})
}
...
}
```

Finally, use the `verify()` function to verify the proof stored in `sismoConnectResponse` with respect to the requests you built. For example, here we verify that the proof in the `sismoConnectResponse` is cryptographically valid for the `groupId` previously chosen in the constructor.

```solidity
function doSomethingUsingSismoConnect(bytes memory sismoConnectResponse) public {
    // store the result of the verification
    SismoConnectVerifiedResult memory sismoConnectVerifiedResult = 
    // verify the proof with respect to the claim request
    verify(sismoConnectResponse, claimRequest);
    
    // You can also pass the signedMessage as argument here (see Example 2)
    // verify(sismoConnectResponse, claimRequest, signedMessage);
}
```

If your proof is valid, the contract will continue its execution, otherwise it will reject an error.

## Documentation

## `verify()`

The `verify()` function allows you to verify a proof generated by the [Sismo Vault app](../../what-is-sismo/data-vault.md) with respect to some requests.

```solidity
function verify(
    bytes memory responseBytes, // required
    AuthRequest memory auth, // optional
    ClaimRequest memory claim, // optional
    SignatureRequest memory signature, // optional
    bytes16 namespace // optional
) public returns (SismoConnectVerifiedResult memory)
```

The function can take these 5 arguments:

* `responseBytes` _(required)_: The response sent back by the [Data Vault](../data-vault-app.md). It contains the [appId](./#appid), the [namespace](./#namespace), the [version](./#version) and the proof corresponding to the [Data requests](./#data-requests).

The function needs to verify that the proof is cryptographically valid but also that it has been well generated from the Data request specified in the frontend. To do this, we also need to setup the same requests in the contract:

* [`claim`](./#claim): The object that holds all the information needed to generate proof of group ownership.
* [`auth`](./#auth): The object that holds all the information needed to generate proof of account membership.
* [`signature`](./#signedmessage): It contains the message that the user should sign.
* [`namespace`](./#namespace): The namespace of the application that the contract uses.

And it returns a [`SismoConnectVerifiedResult`](solidity-library.md#zkconnectverifiedresult).

### `responseBytes` _(required)_

The `responseBytes` is the encoded version of the `sismoConnectResponse`, the response that the frontend received from the Data Vault App.

Once decoded here is the type of the `sismoConnectResponse`:

```solidity
struct SismoConnectResponse {
    // the app identifier (registered in the Sismo Factory)
    bytes16 appId;
    // the app service from which the proof is requested
    // default: bytes16(keccak256("main"))
    bytes16 namespace;
    // the version of the Data Vault app
    // default: "sismo-connect-v2"
    bytes32 version;
    // A message provided by the user and signed with the vault.
    bytes signedMessage;
    // the array of Sismo Connect proofs generated
    // only one proof is generated for now)
    SismoConnectProof[] proofs;
}
```

**`proofs[]`** : The array that contains all the sismoConnectProofs the frontend provide to the contract. Learn more about proofs [**here**](./#proofs).\
A sismoConnectProof stores several objects:

```solidity
struct SismoConnectProof {
  Claim[] claims;
  Auth[] auths;
  bytes32 provingScheme;
  bytes proofData;
  bytes extraData;
}
```

[**`claim`**](./#claim) : The data requested to generate a group membership proof for a specific value.

```solidity
struct Claim {
  ClaimType claimType; // default: GTE
  // the group identifier used to check
  // if the user is eligible in order to generate the zero-knowledge proof.
  bytes16 groupId;
  // the timestamp of the group snapshot for which the user had to be eligible to
  // in order to generate the zero-knowledge proof.
  bytes16 groupTimestamp;
  // Make the value the user wants to use to prove membership selectable
  // e.g. value is 1, the user has a value of 3, he can choose to prove the value 2
  bool isSelectableByUser;
  // A group is a mapping of account and value pairs.
  // Limit eligibility to users in the group with a specified value.
  uint256 value;
  bytes extraData;
}

enum ClaimType {
  GTE,
  GT,
  EQ,
  LT,
  LTE
}
```

[**`auth`**](./#auth) : The data requested to generate a proof of account ownership

```solidity
struct Auth {
  AuthType authType; // default: VAULT
  // (soon™) Does not reveal the userId with which the user performs the auth
  bool isAnon; // false
  // Make the account whose ownership the user wants to prove selectable
  bool isSelectableByUser;
  // The id of the account
  // e.g. if the authType is TWITTER, the userId will be your twitterId.
  uint256 userId;
  bytes extraData;
}

enum AuthType {
  VAULT,
  GITHUB,
  TWITTER,
  EVM_ACCOUNT
}
```

**`provingScheme`** : The proving scheme that the [Data Vault app](../data-vault-app.md) used to generate the proof and by the verify to verify the proof.

**`proofData`** : The proof content.

**`extraData`** : other data that can be used in the future by other proving scheme. Currently not used in the current proving scheme use: the [Hydra-S2](../../technical-concepts/proving-schemes/hydra-s2.md).

The next objects are the references that allow the `verify()` function to ensure that the proof sent by the user matches to the proof expected by the contract:

### [`claimRequest`](./#claim) _(optional)_

The data requested to generate a group membership proof for a specific value.

```solidity
struct ClaimRequest {
  ClaimType claimType; // default: GTE
  bytes16 groupId;
  bytes16 groupTimestamp; // default: bytes16("latest")
  uint256 value; // default: 1
  // flags
  bool isOptional; // default: false 
  bool isSelectableByUser; // default: true
  bytes extraData; // default: ""
}

enum ClaimType {
  GTE,
  GT,
  EQ,
  LT,
  LTE,
}

// Example: Build your Sismo Contributor level 2 claim
Claim memory myExampleClaim = buildClaim({
    groupId: 0xe9ed316946d3d98dfcd829a53ec9822e,
    value: 2
})
```

### [`authRequest`](./#auth) _(optional)_

The data requested to generate a proof of account ownership.

```solidity
struct AuthRequest {
  AuthType authType;
  uint256 userId; // default: 0
  // flags
  bool isAnon; // default: false -> true not supported yet
  bool isOptional; // default: false
  bool isSelectableByUser; // default: true
  bytes extraData; // default: ""
}

enum AuthType {
  VAULT,
  GITHUB,
  TWITTER,
  EVM_ACCOUNT
}

// Example: Build your Twitter auth
Auth memory myExampleAuth = buildAuth({
    authType: authType.TWITTER
})
```

### [`signatureRequest`](./#signedmessage) _(optional)_

A message provided by the user and signed with the Vault.

```solidity
// Example of a signedMessage
struct SignatureRequest {
  bytes message; // default: "MESSAGE_SELECTED_BY_USER"
  bool isSelectableByUser; // default: false
  bytes extraData; // default: ""
}

// Example: Build your signed message
signature: buildSignature({message: message})
```

### [`namespace`](./#namespace) _(optional)_

By default set to “main”. You can optionally define a `namespace` on top of the `appId` to use the zkConnect flow in different parts of your application. You can see an example of two different namespaces used at the end of the [zkConnect server documentation](server.md).

### SismoConnectVerifiedResult

The `sismoConnectVerifiedResult` is the object returned by the `verify()` function if the proof verification passed. It contains all the verifications processed, that is:

* The claim: `verifiedClaims`
* The auth: `verifiedAuths`
* The signed message `signedMessages`

```solidity
struct SismoConnectVerifiedResult {
  bytes16 appId;
  bytes16 namespace;
  bytes32 version;
  VerifiedAuth[] auths;
  VerifiedClaim[] claims;
  bytes signedMessage; 
}

struct VerifiedAuth {
  AuthType authType;
  bool isAnon; // false
  // Contains the account id of the user regarding the requested auth
  // May contain a vaultId, a githubId or a twitterId
  uint256 userId;
  bytes extraData;
  bytes proofData;
}

struct VerifiedClaim {
  ClaimType claimType;
  bytes16 groupId;
  bytes16 groupTimestamp;
  uint256 value;
  bytes extraData;
  // the identifier of the proof, unique for each different namespace
  uint256 proofId;
  bytes proofData;
}
```

If you want info on `VaultId` and `ProofId`, check this [Section](./#vault-id-and-proof-ids).

{% hint style="info" %}
You can find more detailed description of certain objects in the Glossary [**here**](./#glossary).
{% endhint %}
