---
description: Request proofs from your user
---

# zkConnect Client: Request

The [zkConnect](../../what-is-sismo/zkconnect.md) Client is a frontend package built on top of the [Sismo Data Vault app](../data-vault-app.md) (the prover) to easily request proofs from your users. You can see a full guide on how to integrate zkConnect into your application [here](../../tutorials/zkconnect/zk-connect-guide.md).

## Installation

Install zkConnect client package in your frontend with `npm` or `yarn`:

```bash
# with npm
npm install @sismo-core/zk-connect-client
# with yarn
yarn add @sismo-core/zk-connect-client
```

{% hint style="success" %}
Make sure to have at least v18.15.0 as Node version. You can encounter issues with ethers dependencies if not.
{% endhint %}

## Usage

#### Configuration

The first step for integrating zkConnect in your frontend is to create a `zkConnectConfig`. This config will require an `appId` and can be customized with [optional fields.](zkconnect-client-request.md#zkconnectclientconfig) You can go to the [Sismo Factory](https://factory.sismo.io/apps-explorer) to register an appId.

```typescript
import { ZkConnect, ZkConnectClientConfig, DataRequest } from "@sismo-core/zk-connect-client";

const zkConnectConfig: ZkConnectClientConfig = {
  // you will need to register an appId in the Factory
  appId: "0x8f347ca31790557391cec39b06f02dc2", 
}

// create a new ZkConnect instance with the client configuration
const zkConnect = ZkConnect(zkConnectConfig);
```

#### Request proofs from your users for a Claim&#x20;

Request proofs from your users by creating a `ClaimRequest` and calling the `request` function of the zkConnect client. Only the `groupId` in the `ClaimRequest` is mandatory.

```typescript
const CLAIM_REQUEST = { 
    // ID of the group the user should be a member of
    groupId: "0x42c768bb8ae79e4c5c05d3b51a4ec74a",
};

// The `request` function sends your user to the Sismo Vault App to generate the proof.
// After the proof generation, the user is redirected with it to your app
zkConnect.request({ claimRequest: CLAIM_REQUEST });
```

#### Request proofs from your users for a Auth&#x20;

Request proofs from your users by creating a `AuthRequest` and calling the `request` function of the zkConnect client. Only the `authType` in the `ClaimRequest` is mandatory.

```typescript
const AUTH_REQUEST = { 
    authType: AuthType.ANON,
};

zkConnect.request({ authRequest: AUTH_REQUEST });
```

#### Request proofs from your users for a SignedMessage

Request proofs from your users by creating a `MessageSignatureRequest` and calling the `request` function of the zkConnect client.

```typescript
zkConnect.request({ messageSignatureRequest: "Your message here" });
```

#### Get proofs from your users&#x20;

Receive proofs in a `zkConnectResponse` by calling the `getResponse` function when the user is redirected back to your application.&#x20;

```typescript
// The `getResponse` function returns the proof generated by your user 
// after coming back from the Sismo Vault App.
const zkConnectResponse = zkConnect.getResponse();
```

If you want a response usable on-chain you can use the getResponseBytes function.

```typescript
const zkConnectResponseBytes = zkConnect.getResponseBytes();
```

## Documentation

#### **`ZkConnectClientConfig`**

The `ZkConnectClientConfig` allows you to fully customize your zkConnect integration. Its only mandatory field is the `appId`. For more liberty when prototyping, it also comes with an optional devMode field that allows developers to add their addresses and compute cryptographically valid proofs when redirected to the Sismo Developer Vault.

```typescript
export type ZkConnectClientConfig = {
  // the appId registered in the Factory
  appId: string,
  devMode?: {
    // will use the Dev Sismo Data Vault https://dev.vault-beta.sismo.io/
    enabled?: boolean, 
    // Display a modal at the end of the flow with the response to help you 
    // generate response for development purpose
    displayRawResponse?: boolean;
    // Override all groups 
    devGroups?: {
      groupId?: string;
      groupTimestamp?: number | "latest";
      data?: Record<string, Number | BigNumberish>
    }
  },
  // url of the Sismo Vault App to redirect to
  vaultAppBaseUrl?: string
  // url of the Sismo API used
  sismoApiUrl?: string
}
```

Here is an example of a customized `ZkConnectClientConfig` with a `devMode` enabled and two developer addresses that will be able to generate valid proofs from their developer [Data Vaults](../../what-is-sismo/data-vault.md).

```typescript
const zkConnectConfig: ZkConnectClientConfig = {
  // you will need to register an appId in the Factory
  appId: "0x8f347ca31790557391cec39b06f02dc2", 
  // allows to create valid proofs for specific addresses
  // should only be used when prototyping
  // default: undefined
  devMode?: {
    // will use the Dev Sismo Data Vault https://dev.vault-beta.sismo.io/
    enabled?: true, 
    // overrides a group with these addresses
    devGroups?: {
      groupId: "0x42c768bb8ae79e4c5c05d3b51a4ec74a",
      data: {
        "0x123...abc": 1, 
        "0x456...efa": 2
      },
  },
  // url of the Sismo Vault App to redirect to
  // default: https://vault-beta.sismo.io
  // automatically move to https://dev.vault-beta.sismo.io when devMode.enabled = true
  vaultAppBaseUrl?: "https://dev.vault-beta.sismo.io", 
  // url of the Sismo API used
  // default: https://api.sismo.io
  sismoApiUrl?: "https://api.sismo.io"
}
```

#### `ClaimRequest`

The ClaimRequest object holds all the information needed to generate proof of group membership.&#x20;

```typescript
type Claim = {
    // The groupId from which the proofs are generated
    groupId?: string;
    // The timestamp of the group from which the proofs are generated
    groupTimestamp?: number | "latest"; // default to "latest"
    // The value used in the statement request
    value?: number; // default to 1
    // the comparator used for the requestedValue
    // can be "GTE" or "EQ"
    claimType?: ClaimType; // default to GTE
    extraData?: any; // default to ''
}

enum ClaimType {
  EMPTY,
  GTE,
  GT,
}
```

Here is an example of a customized `ClaimRequest` that, [when requested](zkconnect-client-request.md#request), will generate a proof for the latest data of the groupId `0x42c768bb8ae79e4c5c05d3b51a4ec74a` . The user should have exactly a value of 2 in this group.

```typescript
const CLAIM_REQUEST = { 
    // ID of the group the user should be a member of
    groupId: "0x42c768bb8ae79e4c5c05d3b51a4ec74a",
    // timestamp of the data used for the group
    // default: latest
    groupTimestamp?: "latest" 
    // value the user should have in the group
    // default: 1
    value?: 2, 
    // comparator for the requested value
    // default: "GTE" -> "greater than or equal"
    claimType?: ClaimType.EQ,
};
zkConnect.request({ claimRequest: CLAIM_REQUEST });
```

#### `AuthRequest`

The AuthRequest object holds all the information needed to generate proof of account ownership.&#x20;

```typescript
export type Auth = {
  // twitter// github// evmAccount
  authType: AuthType
}

export enum AuthType {
  EMPTY,
  ANON,
  GITHUB,
  TWITTER,
  EVM_ACCOUNT,
}
```

Here is an example of a customized `AuthRequest` that, [when requested](zkconnect-client-request.md#request), will generate a proof containing a Github Id. The user should have a GitHub in his vault.

```typescript
const AUTH_REQUEST = { 
    authType: AuthType.GITHUB,
};
zkConnect.request({ authRequest: AUTH_REQUEST });
```

#### `SignatureMessageRequest`

The `SignatureMessageRequest` contains the message that the user should sign.

<pre class="language-typescript"><code class="lang-typescript"><strong>const MESSAGE_SIGNATURE_REQUEST = "Your message";
</strong>
zkConnect.request({ messageSignatureRequest: MESSAGE_SIGNATURE_REQUEST });
</code></pre>

#### `request()`

```typescript
function request({ 
    claimRequest, 
    authRequest, 
    messageSignatureRequest, 
    namespace, 
    callbackPath 
}: RequestParams): void
```

The `request` function redirects your user to the Sismo Vault App to generate the proof.

```typescript
export type RequestParams = {
  claimRequest?: Claim;
  authRequest?: Auth;
  messageSignatureRequest?: any;
  namespace?: string;
  // the path to redirect your users with proofs
  // default: empty
  // example: /custom-callback-path
  callbackPath?: string;
};
```

Here is an example of a customized usage of the request function. You want that your users generate a proof in their Sismo Data Vault that proves you they are a member of the group with id `0x42c768bb8ae79e4c5c05d3b51a4ec74a` with at least of value of 2 in it. This proof should be made for the service named "my-private-poll-1" and when generated you want them to be redirected to the path "https://poll.xyz/call-back-path/my-private-poll-1".

```typescript
const CLAIM_REQUEST = { 
    groupId: "0x42c768bb8ae79e4c5c05d3b51a4ec74a",
    value?: 2, 
    claimType?: ClaimType.GTE,
};

zkConnect.request({
    claimRequest: CLAIM_REQUEST,
    namespace: "my-private-poll-1",
    callbackPath: "/call-back-path/my-private-poll-1"
})
```

{% hint style="info" %}
Namespace is highly interesting when you want your users to generate proofs for each service in an app. You can see more information about how to use it in the [zkConnect Server package documentation](zkconnect-server-verify-off-chain.md).&#x20;
{% endhint %}

#### `getResponse()`

```typescript
function getResponse(): ZkConnectResponse | null
```

The `getResponse` function returns the [`ZkConnectResponse`](zkconnect-client-request.md#zkconnectresponse) object containing the `verifiableStatements` with proofs generated by your user after coming back from Sismo Vault App. Proofs must be sent to your backend and verified thanks to the [`@sismo-core/zk-connect-server`](https://www.npmjs.com/package/@sismo-core/zk-connect-server) package.

#### `getResponseBytes()`

```typescript
function getResponseBytes(): string | null
```

The `getResponseBytes` function returns the response encoded in bytes usable by the zk-connect-solidity librairy.

#### `ZkConnectResponse`

```typescript
type ZkConnectResponse = {
    // the appId registered in the Factory
    appId: string;
    // zk connect version
    version: string;
    // service from which the proof is requested
    namespace?: string;
    proofs: ZkConnectProof[]
}

type ZkConnectProof = {
    auth?: Auth;
    claim?: Claim;
    signedMessage?: string | any;
    provingScheme: string;
    proofData: string;
    extraData: any;
}
```
